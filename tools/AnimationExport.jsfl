xjsfl.init(this);var prefix = 'line_';//.matrixvar doc = fl.getDocumentDOM();var timeline = doc.getTimeline();clear();/** * traverse items * @param {timeline.layers} targetlayers * @param {String} itemName for output */function traverse(layers, itemName) {	var layerLength = layers.length;	for (var i = 0; i < layerLength; i++) {		var layer = layers[i];		if (layer.layerType === "guide"){			continue;		}				var frames = layer.frames;				var frameLength = frames.length;		for (var j = 0; j < frameLength; j++) {			var frame = frames[j];			//trace(j);			//trace(frame.tweenType);// == 'motion';			//trace('startframe: '+frame.startFrame);			//printObject(frame);			//continue;						//check if frame is keyframe			if (frame.startFrame == j){				var label = frame.name;				if (label && !labels[label]){					if(frame.name.length > 0) {						labels[frame.name] = j;					}				}								var actionScript = frame.actionScript;				if (actionScript) {					code[j] = actionScript.replace(/\n|\r|\t/g, "");				}										//elements loop				if (frame.elements.length>1){					throw "There is more than 1 element on Layer "+i+". This is not supported.";					break;				}								element = frame.elements[0];				if (element){					var name = layer.name.replace(/\n|\r|\t|\s/g, "");					//name = prefix+i;					var interpolation = frame.tweenType == 'motion' ? 'linear':'none';										if (!animations.hasOwnProperty(name)){						animations[name] = createAnimation(j);						var animationData = animations[name].frames;						var properties = getProperties(element);												animationData.push({frame: j, interpolation:interpolation, properties:properties});											}					else{						var animationData = animations[name].frames;						var properties = optimizeProperties(getProperties(element), animationData);						if (properties!=null){							animationData.push({frame: j, interpolation:interpolation, properties:properties});						}					}				}			}					}			}}var timelineData= {	settings:{fps:doc.frameRate, numFrames:timeline.frameCount-1},	labels:{},	code:{},	animations:{}	};	var animations = timelineData.animations;var labels = timelineData.labels;var code = timelineData.code;var roundPixels = true;init();function init(){	traverse(timeline.layers, timeline.name);	printResult()}//only return those properties that changedfunction optimizeProperties(newProperties, animationData){	var properties = null;	if (animationData[animationData.length-1].interpolation == 'none'){		return newProperties;	}		for (var prop in newProperties){		frameLoop:		for (var i = animationData.length-1; i>=0; i--){			var frameData = animationData[i].properties;			if (frameData[prop] != undefined){				if (newProperties[prop] != frameData[prop]){					if (properties==null){						properties = {};					}					properties[prop] = newProperties[prop];				}				break frameLoop;			}		}	}		return properties;}function createAnimation(startFrame){	return  {settings:{startFrame:startFrame}, frames:[]};}function printResult(){	var json = (JSON.encode(timelineData));	trace(json)}function getProperties(clip) {	var t  = clip.matrix;	var data = {		//regX:clip.getChildAt(0).width/2,		//regY:clip.getChildAt(0).height/2,		//x:round(clip.x),		//y:round(clip.y),		alpha:clip.colorAlphaPercent*0.01,		//rotation:round(clip.rotation),		//transform:clip.transform.matrix		a:t.a,b:t.b,c:t.c,d:t.d,tx:t.tx,ty:t.ty	};		return data;}function printObject(obj){	for (var prop in obj){		trace(prop+' '+obj[prop]);	}}//todo: implement numbers after comma/*function round(value,numbers=0){	if (roundPixels){		value = Math.round(value);	}		return value;}function processProperty(key, value){	if (key == 'x' || key == 'y'){		if(roundPixels){			value = Math.round(value);		}	}	if (key=='rotation'){			}		return value;}*/